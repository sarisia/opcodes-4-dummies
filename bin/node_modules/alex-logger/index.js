const { protocol } = require('tera-data-parser')
const Command = require('command')
const hexy = require('hexy')

protocol.load(require.resolve('tera-data'));

module.exports = function AlexLogger(dispatch) {
    const command = Command(dispatch)
    const startTime = Date.now();
	
	let logC = false
	let logS = false
	let logRaw = true
	let logRawUnkOnly = true
	let logJson = true
	let logUnk = true
	let logUnkOnly = false
	let logPaste = false
	
	let searchExpr = null

	let blacklist = ['S_SOCIAL', 'S_NPC_LOCATION', 'S_USER_LOCATION', 'S_RESPONSE_GAMESTAT_PONG', 'S_CHAT', 'S_PARTY_MATCH_LINK'];
		
	command.add('logC', () => {
		logC = !logC
		command.message(`Client packet logging is now ${logC ? 'enabled' : 'disabled'}.`)
	});
	
	command.add('logS', () => {
		logS = !logS;
		command.message(`Server packet logging is now ${logS ? 'enabled' : 'disabled'}.`)
	});
	
	command.add('logRaw', (arg) => {
		arg = ''+arg
		arg = arg.toLowerCase()
		
		if (['true', 'yes', 'y', '1'].includes(arg)) {
			logRaw = true
			logRawUnkOnly = false
		} else if (['false', 'no', 'n', '0'].includes(arg)) {
			logRaw = false
			logRawUnkOnly = false
		} else if (['unk', 'u', '2'].includes(arg)) {
			logRaw = true
			logRawUnkOnly = true
		} else {
			logRaw = !logRaw
			logRawUnkOnly = false
		}
		
		command.message(`Raw packet logging is now ${logRaw ? 'enabled' : 'disabled'}${logRawUnkOnly ? ' (only unknown packets)' : ''}.`)
	});
	
	command.add('logJson', () => {
		logJson = !logJson
		command.message(`Json packet logging is now ${logJson ? 'enabled' : 'disabled'}.`)
	});
	
	command.add('logPaste', () => {
		logPaste = !logPaste
		command.message(`Raw packet pasting format is now ${logPaste ? 'enabled' : 'disabled'}.`)
	});
	
	command.add('logUnk', (arg) => {
		arg = ''+arg
		arg = arg.toLowerCase()
		
		if (['true', 'yes', 'y', '1'].includes(arg)) {
			logUnk = true
			logUnkOnly = false
		} else if (['false', 'no', 'n', '0'].includes(arg)) {
			logUnk = false
			logUnkOnly = false
		} else if (['only', 'o', '2'].includes(arg)) {
			logUnk = true
			logUnkOnly = true
		} else {
			logUnk = !logUnk
			logUnkOnly = false
		}
		
		command.message(`Unknown packet logging is now ${logUnk ? 'enabled' : 'disabled'}${logUnkOnly ? ' (only)' : ''}.`)
	});
	
	command.add('logSearch', (s) => {
		if (s === '' || s === undefined) s = null
		searchExpr = s;
		
		if (searchExpr !== null) {
			searchExpr = ''+searchExpr
			command.message(`Logger search expression set to: ${searchExpr}`);
		} else {
			command.message(`Logger search disabled.`);
		}
	});
	
	command.add('logBlack', (name) => {
		if (name === null || name === undefined) {
			command.message('Invalid');
			return
		}
		var index = blacklist.indexOf(name);
		if (index > -1) {
			blacklist.splice(index, 1);
			command.message('Now showing '+name+'.');
		} else {
			blacklist.push(''+name);
			command.message('Now hiding '+name+'.');
		}
	});
	
	command.add('logBlackShow', (name) => {
		for (let item of blacklist) {
			command.message(item)
		}
	});
	
	command.add('logBlackClear', (name) => {
		blacklist = []
		command.message(`Logger blacklist cleared.`)
	})
	
	function pad(n, l, c = '0') 
	{
		return String(c).repeat(l).concat(n).slice(-l);
	}
	
	function hexDump(data) 
	{
		if (logPaste) {
			return data.toString('hex')
		} else {
			return hexy.hexy(data)
		}
	}
	
	function timestamp() 
	{
		return pad(Date.now() - startTime, 9, ' ')
	}
	
	function packetArrow(incoming) 
	{
		return incoming ? '<-' : '->'
	}
	
	function printUnknown(code, data, incoming) 
	{
		console.log(`${timestamp()} ${packetArrow(incoming)} (id ${code})`)
		if (logRaw) console.log(hexDump(data))
	}
	
	function printKnown(name, packet, incoming, code, data, defPerhapsWrong) 
	{
		let json = JSON.stringify(packet, null, 4)
		console.log(`${timestamp()} ${packetArrow(incoming)} ${name} (id ${code}${defPerhapsWrong ? ', DEF WRONG!!!)' : ')'}`)
		if (logJson) console.log(json)
		if (logRaw && (defPerhapsWrong || !logRawUnkOnly)) console.log(hexDump(data))
	}
	
	function isDefPerhapsWrong(name, packet, incoming, data) 
	{
		if (incoming && name.slice(0, 2) === 'C_') {
			return true
		}
		if (!incoming && name.slice(0, 2) === 'S_') {
			return true
		}
		
		let protocolVersion = dispatch.base.protocolVersion
		let data2 = protocol.write(protocolVersion, name, '*', packet)
		if ((data.length != data2.length) || !data.equals(data2)) {
			return true
		} else {
			return false
		}
	}
	
	function shouldPrintKnownPacket(name, code, incoming) 
	{
		if (logUnk && logUnkOnly) return false
		
		if (incoming) {
			if (!logS) return false
		} else {
			if (!logC) return false
		}
		
		for (let item of blacklist) {
			if (item.toUpperCase() === name.toUpperCase()) {
				return false
			}
			
			if (item.toUpperCase() === (''+code)) {
				return false
			}
		}
		
		if (searchExpr !== null && !packetMatchesSearch(name, code)) {
			return false
		}
		
		return true
	}
	
	function shouldPrintUnknownPacket(code, incoming) 
	{
		if (!logUnk) return false
		
		if (incoming) {
			if (!logS) return false
		} else {
			if (!logC) return false
		}
		
		for (let item of blacklist) {
			if (item.toUpperCase() === (''+code)) {
				return false
			}
		}
		
		if (searchExpr !== null && !packetMatchesSearch('', code)) {
			return false
		}
		
		return true
	}
	
	function packetMatchesSearch(name, code)
	{
		if (searchExpr === (''+code)) {
			return true
		} else {
			if (name !== '' && new RegExp(searchExpr).test(name)) {
				return true
			}
		}
		
		return false
	}
	
    dispatch.hook('*', 'raw', { order: 999, type: 'all' }, (code, data, incoming, fake) => {
		if (!logC && !logS) return
		
		let protocolVersion = dispatch.base.protocolVersion
		let name = null
		let packet = null
		
		try {
			name = protocol.maps.get(protocolVersion).code.get(code)
		} catch(e) {
			name = null
		}
		
		if (name) {
			try {
				packet = protocol.parse(protocolVersion, code, '*', data)
			} catch(e) {
				packet = null
			}

			if (packet) {
				let defPerhapsWrong = isDefPerhapsWrong(name, packet, incoming, data)
				if (shouldPrintKnownPacket(name, code, incoming)) {
					printKnown(name, packet, incoming, code, data, defPerhapsWrong)
				}
			}
		}
		
		if (!name || !packet) {
			if (shouldPrintUnknownPacket(code, incoming)) {
				printUnknown(code, data, incoming)
			}
		}
    })
};
